
main: File(mod, fns) -> 
   File(mod, fns > !explicit_currying > !join_definitions > !matches_to_ifs > !remove_brackets);

# Explicit currying in functions that match multiple arguments

explicit_currying: fns -> !map[!explicit_currying_one] fns;

explicit_currying_one: FnDecl(_, _) -> .id;
explicit_currying_one: FnDef(name, [p], body){..a} -> FnDef(name, p, body){..a};
explicit_currying_one: FnDef(name, [p|t], body){..a} -> FnDef(name, p, !explicit_currying_inner Closure(t, body)){..a};
explicit_currying_inner: Closure([p], body) -> Closure(p, body);
explicit_currying_inner: Closure([p|t], body) -> Closure(p, !explicit_currying_inner Closure(t, body));

# Separated function definitions desugaring into single function with branch

join_definitions: fns -> !group_functions fns > !map[!merge_functions];

group_functions: fns -> 
     func_map := .new_map ()
  in !env_map[!group_one] (func_map, fns) > !fst;

group_one: (env, FnDecl(_, _)) -> .id;
group_one: (env, FnDef(name, pattern, body){Type(t)}) ->
       (fn_group    := .get[name] env
    in new_fn_group := [FnDef(name, pattern, body){Type(t)} | fn_group]
    in new_env      := .put[name, new_fn_group] env
    in (new_env, FnDef(name, pattern, body){Type(t)}))
    +  new_fn_group := [FnDef(name, pattern, body){Type(t)}]
    in (.put[name, new_fn_group] env, FnDef(name, pattern, body){Type(t)});

merge_functions: (name, [h{Type(ty)}|t]) ->
     FnDef(name, "_arg", !reverse [h|t] > !map[!to_match_branch] > !merge_match_branches){Type(ty)};
to_match_branch: FnDef(_, p, b) -> MatchBranch(p, b);
merge_match_branches: branches -> Match(Ref("_arg"), branches);

# Match desugaring into if-then-else chains

matches_to_ifs: fns -> !topdown[!try[.desugar_match]] fns;

desugar_match: Match(arg, branches) ->
   !map[!branch_to_if[arg]] branches > !reverse > !reduce[!merge_if] (Panic(), .id);

branch_to_if[arg]: MatchBranch(pattern, body) ->  
   If(!pattern_to_boolean (arg, pattern), !pattern_to_statements (arg, pattern, body));

pattern_to_boolean: (arg, PatternVar(name)) -> True();
pattern_to_boolean: (arg, PatternNum(num)) -> Eq(arg, num);
pattern_to_boolean: (arg, PatternStr(str)) -> Eq(arg, str);
pattern_to_boolean: (arg, [p]) -> .pattern_to_boolean (arg, p);

pattern_to_statements: (arg, PatternVar(name), body) -> Let([Decl(name, AnyType(), arg)], body);
pattern_to_statements: (arg, PatternNum(_), body) -> body;
pattern_to_statements: (arg, PatternStr(_), body) -> body;
pattern_to_statements: (arg, [p], body) -> .pattern_to_statements (arg, p, body);

merge_if: (Panic(), If(expr, stmt)) -> If(expr, stmt, Panic());
merge_if: (if_chain, If(expr, stmt)) -> If(expr, stmt, if_chain);

# Remove brackets

remove_brackets: t -> !bottomup[.try[.remove_bracket]] t;
remove_bracket: Brackets(t) -> t;
