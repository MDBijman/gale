module modeling

type Vertex (std.i32 x, std.i32 y, std.i32 z) 
type Face (Vertex a, Vertex b, Vertex c)
type Model (ref [] Face faces)

factorial = fn (std.i32 n) -> std.i32 = case [
	| call eq (n, 1) -> 1
	| call eq (1, 1) -> call mul (n, call factorial (call sub (n, 1)))
]

create_vertex = fn (std.i32 x, std.i32 y, std.i32 z) -> Vertex = {
	call Vertex (x, y, z)
}

create_face = fn (Vertex a, Vertex b, Vertex c) -> Face = {
	call Face (a, b, c)
}

translate_v = fn (Vertex v, std.i32 x, std.i32 y, std.i32 z) -> Vertex = {
	call Vertex (call add (v.x, x), call add (v.y, y), call add (v.z, z))
}

translate_f = fn (Face f, std.i32 x, std.i32 y, std.i32 z) -> Face = {
	call Face (call translate_v (f.a, x, y, z), call translate_v (f.b, x, y, z), call translate_v (f.c, x, y, z))
}

a = call Vertex (1, 1, 1)
b = call Vertex (2, 2, 2)
c = call Vertex (3, 4, 3)
d = call Face (a, b, c)

z = case [
	| call gte(0, 1) -> 3
	| call lt(1, 3) -> call factorial (5)
]

export Face Vertex
