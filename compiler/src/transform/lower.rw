main: File(ModuleName(mod), fns) -> Program(Name(mod), !flatmap_some[!lower] fns);

lower: FnDecl(func, type) -> [];
lower: FnDef(func, arg, body){Type(t)} ->
    Function(func, Type(t), !extract_pattern, !lower body > .try[.flatten_some] > !do_hoist > !make_return);

extract_pattern: FnDef(_, a, _) -> Pattern(a);

# Lowering AST nodes

lower: Let(decls, e) -> Hoist(!map[!lower] decls, !lower e);

lower: Let(decls) -> !map[!lower] decls;

lower: Decl(n, t, e) -> Store(n, !lower e);

lower: Appl(Ref(fn), arg){Type(Unit())} ->
     tmp_name := !gen_name "tmp"
  in arg_name := !gen_name "tmp"
  in [
      Store(arg_name, !lower arg),
      Store(tmp_name, Call(fn, Load(arg_name)))
    ];
    
lower: Appl(Ref(fn), a){Type(t)} ->
     tmp_name := !gen_name "tmp"
  in Hoist([
      Store(tmp_name, Call(fn, !lower a))
    ], Load(tmp_name));

lower: Seq(elems) -> !map[!lower] elems;

lower: Seq(elems, res) -> Hoist(!map[!lower] elems, !lower res);

lower: For(bind, list{Type(t)}, body) ->
     end_lbl  := !gen_name "lbl"
  in loop_lbl := !gen_name "lbl"
  in idx_name := !gen_name "tmp"
  in inc_name := !gen_name "tmp"
  in size_name := !gen_name "tmp"
  in list_name := !gen_name "tmp"
  in cond_name := !gen_name "tmp"
  in [
    Store(list_name, !lower list),
    Store(idx_name, UI64(0)),
    Store(inc_name, UI64(1)),
    Store(size_name, Size(Load(list_name))),
    Lbl(loop_lbl),
    Store(cond_name, BinOp("=", Load(size_name), Load(idx_name))),
    JmpIf(end_lbl, Load(cond_name)),
    Store(bind{}, ReadIdx(Load(list_name), Load(idx_name), Type(t))),
    Store(idx_name, BinOp("+", Load(idx_name), Load(inc_name))),
    !lower body,
    Jmp(loop_lbl),
    Lbl(end_lbl)
  ];

lower: Assign(Ref(n), e) -> Store(n, !lower e);

lower: String(i) -> tmp_name := !gen_name "tmp" in Hoist([Store(tmp_name, StringLiteral(i))], Load(tmp_name));

lower: Int(i){Type(Builtin("ui64"))} -> UI64(i);
lower: Int(i) -> UI64(i);

lower: True() -> UI64(1);
lower: False() -> UI64(0);

lower: Panic() -> Panic();

lower: Add(lhs, rhs) -> 
     lhs_tmp_name := !gen_name "tmp"
  in rhs_tmp_name := !gen_name "tmp"
  in res_tmp_name := !gen_name "tmp"
  in Hoist([
    Store(lhs_tmp_name, !lower lhs),
    Store(rhs_tmp_name, !lower rhs),
    Store(res_tmp_name, BinOp("+", Load(lhs_tmp_name), Load(rhs_tmp_name)))
  ], Load(res_tmp_name));

lower: Sub(lhs, rhs) -> 
     lhs_tmp_name := !gen_name "tmp"
  in rhs_tmp_name := !gen_name "tmp"
  in res_tmp_name := !gen_name "tmp"
  in Hoist([
    Store(lhs_tmp_name, !lower lhs),
    Store(rhs_tmp_name, !lower rhs),
    Store(res_tmp_name, BinOp("-", Load(lhs_tmp_name), Load(rhs_tmp_name)))
  ], Load(res_tmp_name));

lower: Mul(lhs, rhs) -> 
     lhs_tmp_name := !gen_name "tmp"
  in rhs_tmp_name := !gen_name "tmp"
  in res_tmp_name := !gen_name "tmp"
  in Hoist([
    Store(lhs_tmp_name, !lower lhs),
    Store(rhs_tmp_name, !lower rhs),
    Store(res_tmp_name, BinOp("*", Load(lhs_tmp_name), Load(rhs_tmp_name)))
  ], Load(res_tmp_name));

lower: Eq(lhs, rhs) -> 
     lhs_tmp_name := !gen_name "tmp"
  in rhs_tmp_name := !gen_name "tmp"
  in res_tmp_name := !gen_name "tmp"
  in Hoist([
    Store(lhs_tmp_name, !lower lhs),
    Store(rhs_tmp_name, !lower rhs),
    Store(res_tmp_name, BinOp("=", Load(lhs_tmp_name), Load(rhs_tmp_name)))
  ], Load(res_tmp_name));

lower: Not(cond) -> 
     op_tmp := !gen_name "tmp"
  in res_tmp := !gen_name "tmp"
  in Hoist([
    Store(op_tmp, !lower cond),
    Store(res_tmp, UnOp("~", Load(op_tmp)))
  ], Load(res_tmp));

lower: Ref(n) -> Load(n);
lower: Array(elems) -> Array(!map[!lower] elems);

lower: ArrIndex(arr{Type(t)}, idx) -> 
     arr_name := !gen_name "tmp"
  in idx_name := !gen_name "tmp"
  in tmp_name := !gen_name "tmp"
  in elem_type := !array_element_type Type(t)
  in Hoist([
    Store(arr_name, !lower arr),
    Store(idx_name, !lower idx),
    Store(tmp_name, ReadIdx(Load(arr_name), Load(idx_name), elem_type))
  ], Load(tmp_name));

array_element_type: Type(HeapArray(elem)) -> Type(elem);
array_element_type: Type(Array(elem, _)) -> Type(elem);

lower: If(cond, then, else) ->
     end_lbl  := !gen_name "lbl"
  in else_lbl := !gen_name "lbl"
  in tmp_name := !gen_name "tmp"
  in res_name := !gen_name "tmp"
  in low_then := !lower then 
  in low_else := !lower else
  in Hoist([
    Store(tmp_name, !lower Not(cond)),
    JmpIf(else_lbl, Load(tmp_name)),
    Store(res_name, low_then),
    Jmp(end_lbl),
    Lbl(else_lbl),
    Store(res_name, low_else),
    Lbl(end_lbl)
  ], Load(res_name));

lower: If(cond, then) ->
     end_lbl := !gen_name "lbl"
  in tmp_name := !gen_name "tmp"
  in res_name := !gen_name "tmp"
  in low_then := !lower then
  in [
    Store(tmp_name, !lower Not(cond)),
    JmpIf(end_lbl, Load(tmp_name)),
    low_then,
    Lbl(end_lbl)
  ];

lower: [h|t] -> !map[!lower] [h|t];

# Logic for hoisting statements to blocks

do_hoist: t -> !bottomup[.try[.hoist]] t > .try[.hoist_to_arr];
hoist: Hoist(stmts, Hoist(stmts2, expr)) -> Hoist(!concat (stmts, stmts2), expr);
hoist: ?con(..subterms) -> 
     [h|t] := !flatmap_some[.extract_hoisted_stmts] !retain_all[.is_hoist] subterms
  in new_subterms := !map[.try[.extract_hoisted_expr]] subterms
  in Hoist([h|t], ?con(..new_subterms));
hoist: [h|t] -> !flatmap_some[.try[.hoist_to_arr]] [h|t];
hoist: (..subts) -> new_subts := !flatmap_some[.try[.hoist_to_arr]] subts in (..new_subts);

extract_hoisted_stmts: Hoist(stmts, _) -> stmts;
extract_hoisted_expr: Hoist(_, expr) -> expr;
hoist_to_arr: Hoist(stmts, expr) -> .concat (stmts, [expr]);
wrap_hoist_return: Hoist(stmts, expr) -> Hoist(stmts, Return(expr));
is_hoist: Hoist(_, _) -> .id;

make_return: input -> (list, last) := !split_last input
  in .concat (list, [Return(last)]);
