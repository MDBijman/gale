main: File(fns) -> Program(!flatmap_some[!lower] fns);

lower: FnDecl(func, type) -> [];
lower: FnDef(func, arg, body) ->
    Function(func, !extract_pattern, !lower body > .try[.flatten_some] > !do_hoist > !make_return);

extract_pattern: FnDef(_, a, _) -> Pattern(a);

# Lowering AST nodes

lower: Let(decls, e) -> Hoist(!map[!lower] decls, !lower e);
lower: Decl(n, t, e) -> Store(n, !lower e);
lower: Appl(fn, arg){Type(t)} ->
     tmp_name := !gen_name "tmp"
  in Hoist([Store(tmp_name, Call(fn, !lower arg))], Load(tmp_name));
lower: Int(i){Type(Builtin("ui8"))} -> UI8(i);
lower: Int(i) -> UI8(i);
lower: True() -> True();
lower: False() -> False();
lower: Add(lhs, rhs) -> BinOp("+", !lower lhs, !lower rhs);
lower: Sub(lhs, rhs) -> BinOp("-", !lower lhs, !lower rhs);
lower: Eq(l, r)      -> BinOp("=", !lower l, !lower r);
lower: Not(cond)     -> UnOp("~", !lower cond);
lower: Ref(n) -> Load(n);
lower: Array(elems) -> Array(!map[!lower] elems);
lower: If(cond, then, else) ->
     end_lbl  := !gen_name "lbl"
  in else_lbl := !gen_name "lbl"
  in tmp_name := !gen_name "tmp"
  in res_name := !gen_name "tmp"
  in low_then := !lower then 
  in low_else := !lower else
  in Hoist([Store(tmp_name, !lower Not(cond)), JmpIf(else_lbl, Load(tmp_name)), Store(res_name, low_then), Jmp(end_lbl), Lbl(else_lbl), Store(res_name, low_else), Lbl(end_lbl)], Load(res_name));
lower: If(cond, then) ->
     end_lbl := !gen_name "lbl"
  in tmp_name := !gen_name "tmp"
  in res_name := !gen_name "tmp"
  in low_then := !lower then
  in Hoist([Store(tmp_name, !lower Not(cond)), JmpIf(end_lbl, Load(tmp_name)), Store(res_name, low_then), Lbl(end_lbl)], Load(res_name));
lower: [h|t] -> !map[!lower] [h|t];

# Logic for hoisting statements to blocks

do_hoist: t -> !bottomup[.try[.hoist]] t > .try[.hoist_to_arr];
hoist: Hoist(stmts, Hoist(stmts2, expr)) -> Hoist(!concat (stmts, stmts2), expr);
hoist: ?con(..subterms) -> 
     [h|t] := !flatmap_some[.extract_hoisted_stmts] !retain_all[.is_hoist] subterms
  in new_subterms := !map[.try[.extract_hoisted_expr]] subterms
  in Hoist([h|t], ?con(..new_subterms));
hoist: [h|t] -> !flatmap_some[.try[.hoist_to_arr]] [h|t];
hoist: (..subts) -> new_subts := !flatmap_some[.try[.hoist_to_arr]] subts in (..new_subts);

extract_hoisted_stmts: Hoist(stmts, _) -> stmts;
extract_hoisted_expr: Hoist(_, expr) -> expr;
hoist_to_arr: Hoist(stmts, expr) -> .concat (stmts, [expr]);
wrap_hoist_return: Hoist(stmts, expr) -> Hoist(stmts, Return(expr));
is_hoist: Hoist(_, _) -> .id;

make_return: input -> (list, last) := !split_last input
  in .concat (list, [Return(last)]);
