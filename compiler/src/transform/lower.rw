main: File(fns) -> Program(!flatmap_some[!lower] fns);

lower: FnDecl(func, type) -> [];
lower: FnDef(func, arg, body){Type(t)} ->
    Function(func, !extract_signature, !lower body > !wrap_return .try[.flatten_some] > .do_hoist);

extract_signature: FnDef(_, a, _){Type(t)} -> In(a);

# Lowering AST nodes

lower: Let(decls, e) -> !flatten_some [!map[!lower] decls, !lower e];
lower: Decl(n, t, e) -> Store(n, !lower e);
lower: Appl(fn, arg){Type(t)} ->
     tmp_name := !gen_name "tmp"
  in Hoist([Store(tmp_name, Call(fn, !lower arg))], Load(tmp_name));
lower: Int(i){Type(Builtin("ui8"))} -> UI8(i);
lower: Add(lhs, rhs){Type(t)} -> BinOp("+", !lower lhs, !lower rhs){Type(t)};
lower: Sub(lhs, rhs){Type(t)} -> BinOp("-", !lower lhs, !lower rhs){Type(t)};
lower: Ref(n) -> Load(n);
lower: Array(elems) -> Array(!map[!lower] elems);
lower: [h|t] -> !map[!lower] [h|t];

# Adds return to final statement in block
wrap_return: [h|t] ->
     (front, last) := !split_last [h|t]
  in .is_simple_value last > .concat (front, [Return(last)])
   + ret_stmts := !to_return last
  in .concat (front, ret_stmts);
wrap_return: t -> .is_simple_value t > Return(t) + !to_return t;

to_return: t -> 
     tmp_name := !gen_name "tmp"
  in [Store(tmp_name, t), Return(Load(tmp_name))];

is_simple_value: Int(_) -> .id;
is_simple_value: Ref(_) -> .id;
is_simple_value: Array(_) -> .id;

# Logic for hoisting statements to blocks
do_hoist: t -> !bottomup[.try[.hoist]] t;
hoist: ?con(..subterms) -> 
     [h|t] := !flatmap_some[.extract_hoisted_stmts] !retain_if[.is_hoist] subterms
  in new_subterms := !map[.try[.extract_hoisted_expr]] subterms 
  in Hoist([h|t], ?con(..new_subterms));
hoist: [h|t] -> !flatmap_some[.try[.hoist_to_arr]] [h|t];
hoist: (..subts) -> new_subts := !flatmap_some[.try[.hoist_to_arr]] subts in (..new_subts);

extract_hoisted_stmts: Hoist(stmts, _) -> stmts;
extract_hoisted_expr: Hoist(_, expr) -> expr;
hoist_to_arr: Hoist(stmts, expr) -> .concat (stmts, [expr]);
is_hoist: Hoist(_, _) -> .id;
