
main: File(lets) -> File(.map[.compile] lets);

compile: Let(n, t, Lambda(p, b)) -> Function(n, .extract_meta, !compile b);
extract_meta: Let(n, t, Lambda(p, b)) -> Meta(InSize(.input_size t), OutSize(.output_size t));

compile: Block(s) -> Scope(Size(.stack_depth (s, 0)), .map[!compile] s);
compile: Let(n, t, e) -> Store(n, !compile e);
compile: Int(i){Type(Builtin("ui8"))} -> UI8(i);
compile: Ref(n) -> Load(n);
compile: Array(elems) -> Array(.map[!compile] elems);
compile: any -> .debug > .fail;

# Should be changed, 'let' should accumulate in block, rhs of let shouldn't 
stack_depth: ([], n)      -> n;
stack_depth: ([h|t], n)   -> !stack_depth (t, .add (!stack_depth h, n));
stack_depth: [h|t]        -> !stack_depth ([h|t], 0);

stack_depth: Let(_, t, e) -> !add (!type_size t, !stack_depth e);
stack_depth: Appl(_, e)   -> !stack_depth e;
stack_depth: String(_)    -> 16;
stack_depth: Ref(_){Type(t)} -> !type_size t;
stack_depth: Int(_){Type(Builtin("ui8"))} -> 1;
stack_depth: Return(e)    -> !stack_depth e;
stack_depth: Return()     -> 0;
stack_depth: Tuple()      -> 0;
stack_depth: Brackets(e)  -> !stack_depth e;
stack_depth: Add(l, r)    -> !add (!stack_depth l, !stack_depth r);
stack_depth: Array(l)     -> !stack_depth (l, 0);
stack_depth: ArrIndex(r, i) -> !add (8, !stack_depth i);

type_size: Type(t) -> !type_size t;
type_size: Builtin("string") -> 16;
type_size: Builtin("ui8") -> 1;
type_size: Array(t, Int(n)) -> !mul (!type_size t, n);
type_size: TypeTuple() -> 0; 
type_size: TypeTuple([t]) -> !type_size t; 
type_size: TypeTuple([t|tail]) -> !add (!type_size t, !type_size TypeTuple(tail)); 
type_size: Int(_) -> 8;

input_size: Type(Func(t, _)) -> !type_size t;
output_size: Type(Func(_, t)) -> !type_size t;
