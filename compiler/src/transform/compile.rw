
main: File(lets) -> File(.all[.compile] lets);

compile: Let(n, t, Lambda(p, b)) -> Function(n, .extract_meta, .compile b);
extract_meta: Let(n, t, Lambda(p, b)) -> Meta(InSize(.input_size t), OutSize(.output_size t));

compile: Block(s) -> Scope(Size(.stack_depth (s, 0)), .all[.compile] s);
compile: Let(n, t, e) -> Store(n, .compile e);
compile: Int(i){Type(Builtin("ui8"))} -> UI8(i);
compile: Ref(n) -> Load(n);

stack_depth: ([h], n)     -> .add (.stack_depth h, n);
stack_depth: ([h|t], n)   -> .stack_depth (t, .add (.stack_depth h, n));

stack_depth: Let(_, t, e) -> .add (.type_size t, .stack_depth e);
stack_depth: Appl(_, e)   -> .stack_depth e;
stack_depth: String(_)    -> 16;
stack_depth: Ref(_)       -> 8;
stack_depth: Int(_){Type(Builtin("ui8"))} -> 1;
stack_depth: Return(e)    -> .stack_depth e;
stack_depth: Return()     -> 0;
stack_depth: Tuple()      -> 0;
stack_depth: Brackets(e)  -> .stack_depth e;
stack_depth: Add(l, r)    -> .max (.stack_depth l, .add (8, .stack_depth r));
stack_depth: Array(l)     -> .stack_depth (l, 0);
stack_depth: ArrIndex(r, i) -> .add (8, .stack_depth i);

type_size: TypeId("string") -> 16;
type_size: TypeId("ui8") -> 1;
type_size: TypeArray(t, Int(n)) -> .mul (.type_size t, n);
type_size: TypeTuple() -> 0; 
type_size: TypeTuple([t]) -> .type_size t; 
type_size: TypeTuple([t|tail]) -> .add (.type_size t, .type_size TypeTuple(tail)); 
type_size: Int(_) -> 8;

input_size: FnType(t, _) -> .type_size t;
output_size: FnType(_, t) -> .type_size t;
